/// <reference types="node" />
import EventEmitter from 'events';
export interface Message<T> {
    subId: number;
    type: string;
    payload: T;
}
export interface TPS {
    time: number;
    price: number;
    size: number;
}
export interface Aggregate {
    time: number;
    open: number;
    high: number;
    low: number;
    close: number;
    volume: number;
    adjValue: number;
}
export interface AggregateResponse {
    expectedClosingTime: number;
    aggregates: Aggregate[];
    resolution: number;
    lastAggregateEndTime: number;
}
export interface Ticker {
    bid: TPS;
    ask: TPS;
    last: TPS;
    pre: TPS;
    open: TPS;
    qualityId: string;
    leverage: string;
    delta: string;
}
interface Options {
    locale: string;
    apiEndpoint: string;
    keepSentMessageHistory: boolean;
    autoReconnect: boolean;
}
export declare class TradeRepublicApi extends EventEmitter {
    private ws;
    private subCounter;
    private locale;
    private sessionToken;
    private sentMessages;
    private keepSentMessageHistory;
    private autoReconnect;
    private apiEndpoint;
    private static DEFAULT_LOCALE;
    private static DEFAULT_APIENDPOINT;
    private static CONNECTED_CONFIRMED_MSG;
    constructor(options?: Partial<Options>);
    /**
     * establish a connection to the Trade Republic websocket
     */
    connect(): void;
    /**
     * supply increasing subscription Ids
     * @returns next subscription Id to be used
     */
    private getNextSubId;
    /**
     * subscribe to the ticker topic of isin
     * @param isin isin
     * @param exchangeId exchangeId, only LSX is supported for now
     * @returns subscriptionId
     */
    subTicker(isin: string, exchangeId?: string): number;
    /**
     * subscribe to a topic by type and specify payload
     * @param type message type
     * @param payload message payload
     * @returns subscriptionId
     */
    sub(type: any, payload: any): number;
    /**
     * subscribe to a topic and wait for a single response
     * @param type message type
     * @param payload message payload
     * @returns response data
     */
    oneShot<T>(type: any, payload: any): Promise<Message<T>>;
    /**
     * emit an event only when they are listened for
     * @param eventName name of the event
     * @param data payload of the event
     */
    private emitIfSubbed;
    /**
     * get all messages that have been sent to the websocket
     * empty if `keepSentMessageHistory` is not enabled
     * @returns map linking subscription Ids to request payloads
     */
    getSentMessages(): Map<number, unknown>;
    /**
     * process an incoming message
     * @param data raw received websocket message
     */
    private handleMessage;
    /**
     * sends a message to the Websocket
     * @param msg message string
     */
    private send;
    /**
     * extracts structured data from an incoming message
     * @param data raw received data
     * @returns Message obj containing subId, type and payload
     */
    private processNewMessage;
}
export {};
